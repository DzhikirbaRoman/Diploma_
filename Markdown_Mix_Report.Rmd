---
title: "Diploma"
author: "Dzhikirba Roman"
date: "2024-03-30"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Set up working directory and for Data Files, Plots
Here I need to set working directory and for data files in it
```{r set dir}
getwd()
working_dir <- "C:/Users/RTIntelektFBT/Desktop/Roman_Project/Diploma_"
setwd(working_dir)
DataFilesFolder <- file.path(working_dir,"Data_Files")
PlotsFolder <- file.path(working_dir,"Plots")
```
## Data reading - Expression matrix and metaData 

```{r Data reading}
# expression matrix
sub_exprs = read.table(file.path(DataFilesFolder,"sub_exprs.tsv"), sep="\t")
head(sub_exprs)

# Meta Data
sub_pdata = read.table(file.path(DataFilesFolder,"sub_sub_pdata.tsv"), sep="\t", header = TRUE)
head(sub_pdata)
# Check how many samples I have from 1 and 2 trimestrs
table(sub_pdata[,c( "trim_term")])

#as.factor(sub_pdata$trim_term)
#sub_pdata$trim_term
```
## Building heatmap using pheatmap
* Unsupervised analysis is a good way to get an understanding of the sources of variation in the data. It can also identify potential outlier samples.

The function cor() can calculate the correlation (on scale 0 - 1) in a pairwise fashion between all samples. This can be then visualised on a heatmap. Among the many options for creating heatmaps in R, the pheatmap library is one of the more popular ones. The only argument it requires is a matrix of numerical values (such as the correlation matrix).
```{r pheatmaps. Sample correlation }
library(pheatmap)
library(tidyverse)
library(dplyr)
### pheatmap for both trimestrs
# here i want to create df that contains trims for sample names to put in as annotation in pheatmap()
sampleinfo <- dplyr::select(sub_pdata, trim_term, Combined.Fetus.Sex)
#class(sampleinfo)
rownames(sampleinfo) <- sub_pdata$arraydatafile_exprscolumnnames
View(sampleinfo)
# creation corMatrix for samples
corMatrix <- cor(sub_exprs,use="c")
pheatmap(corMatrix, width = 300, height = 900,annotation_col = sampleinfo)     

# first trim
names_1trim <- sub_pdata[sub_pdata$trim_term == "First Trimester",]$arraydatafile_exprscolumnnames
names_1trim
corMatrix_1trim <- cor(sub_exprs[,names_1trim],use="c")
pheatmap(corMatrix_1trim, width = 300, height = 900 )     

# second trim
names_2trim <- sub_pdata[sub_pdata$trim_term == "Second Trimester",]$arraydatafile_exprscolumnnames
names_2trim
corMatrix_2trim <- cor(sub_exprs[,names_2trim],use="c")
pheatmap(corMatrix_2trim, width = 300, height = 900 )     

```


## Building Differential Expression table
By far the most-popular package for performing differential expression is limma. The user-guide is extensive and covers the theory behind the analysis and many use-cases (Chapters 9 and 17 for single-channel data such as Illumina and Affymetrix)

[Link for tutorial](https://sbc.shef.ac.uk/geo_tutorial/tutorial.nb.html#Sample_clustering_and_Principal_Components_Analysis)
```{r Differential expression}
library(limma)

# Crucially, we have to allocate the samples in our dataset to the sample groups of interest. A useful function is model.matrix, which will create a design matrix from one of the columns in your sub_pdata Here I choose sub_pdata$trim_term

fit_mod <- model.matrix(~ 0 + as.factor(sub_pdata$trim_term), data = sub_pdata)
fit_mod
## the column names are a bit ugly, so we will rename 
colnames(fit_mod) = c('trim1','trim2')
fit_mod

# The lmFit function is used to fit the model to the data. The result of which is to estimate the expression level in each of the groups that we specified.
fit <- lmFit(sub_exprs, fit_mod)  # fit each probeset to model
fit
#medians <- apply(sub_exprs, 1, median)
#medians

# In order to perform the differential analysis, we have to define the contrast that we are interested in. In our case we only have two groups and one contrast of interest. Multiple contrasts can be defined in the makeContrasts function.
contrast.matrix <- makeContrasts(trim1 - trim2, levels = fit_mod)

## can define multiple contrasts
## e.g. makeContrasts(Group1 - Group2, Group2 - Group3,....levels=design)
# contrasts.fit() Given a linear model fit to microarray data, compute estimated coefficients and standard errors for a given set of contrasts.
fit2 <- contrasts.fit(fit = fit, contrasts =contrast.matrix)
#fit2

#Finally, apply the empirical Bayes’ step to get our differential expression statistics and p-values.
efit <- eBayes(fit2)        # empirical Bayes adjustment
#View(efit)

# The topTable function automatically displays the results for the first contrast
diff_table = topTable(efit, number = nrow(sub_exprs))
nrow(diff_table)
#If we want to know how many genes are differentially-expressed overall we can use the decideTests function.
#decideTests(efit)
diff_table
#nrow(d)

```

## Obtaining Annotation such as ("ENTREZID","GENENAME") via org.Hs.eg.db, and calculating means of gene expre for 1 and 2 trimestrs 
```{r Obtaining Annotation}
library(org.Hs.eg.db)
#keys(org.Hs.eg.db)
#View(sub_exprs)

### Annotation of genes for diff_table
sel = AnnotationDbi::select(org.Hs.eg.db, rownames(diff_table), columns = c("ENTREZID","GENENAME"), keytype="SYMBOL")
sel
# Filtering out Genes, that were not annotated
sel = sel[!is.na(sel$ENTREZID),]

### Annotation of genes for sub_exprs(expression matrix)
sel2 = AnnotationDbi::select(org.Hs.eg.db, rownames(sub_exprs), columns =  c("ENTREZID","GENENAME"), keytype="SYMBOL")
# Filtering out Genes, that were not annotated
sel2 = sel2[!is.na(sel2$ENTREZID),]

# Checking whether all our genes in Expr Matrix are represented in one copy
length(unique(rownames(sub_exprs))) == length(rownames(sub_exprs))
# Checking whether all our genes in sel2 are represented in one copy
length(sel2$ENTREZID) == length(unique(sel2$ENTREZID))

# Checking whether we have NA ENTREZID of genes in sel2
NA %in% sel2$ENTREZID

# Checking whether we have NA names of genes in sub_exprs
NA %in% rownames(sub_exprs)

# Filtering out Genes that were not annotated in Expression Matrix(sub_exprs)
sub_exprs <- sub_exprs[sel2$SYMBOL,]
#View(sub_exprs)

# Checking we have the same of lengths for genes in sel2 and Expression Matrix(sub_exprs)
nrow(sub_exprs)== nrow(sel2)

# Checking we have the same genes in sel2 and in Expression Matrix(sub_exprs)
rownames(sub_exprs) == sel2$SYMBOL

# Checking whether we have FALSE, that means that not all genes names from sub_exprs and sel2 are the same
!(FALSE %in% (rownames(sub_exprs) == sel2$SYMBOL))
# we have FALSE
# it is true when rownames(sub_exprs) = sel2$SYMBOL 

nrow(diff_table)


#View(sel)
#View(diff)
nrow(sel)
nrow(diff_table)

# with merge function we obtain new diff_table where there are only annotated genes, those who were not annotated will be discarded. As result, we obtain diff_table with less number of rows
merged_sel = merge(sel,diff_table, by.x = "SYMBOL", by.y = "row.names")
merged_sel

nrow(merged_sel) == nrow(sub_exprs)

#View(merged_sel)

length(levels(as.factor(sub_pdata$trim_term)))

?which
# Check the length of sub_exprs. If the length is different from one that was previosly, It means some genes have the same names 
difexp_exprs1 = sub_exprs[which(rownames(sub_exprs) %in% merged_sel$SYMBOL),]
nrow(sub_exprs)
nrow(difexp_exprs1)

#rownames(merged_sel)
length(merged_sel$SYMBOL)
length(rownames(sub_exprs))

#View(merged_sel)
# The setdiff() function in R is used to find the set difference between two vectors or sets. It returns the elements that are present in the first vector but not present in the second vector.
missing_rows <- setdiff(rownames(sub_exprs),merged_sel$SYMBOL)
missing_rows
missing_rows <- setdiff(merged_sel$SYMBOL,rownames(sub_exprs))
missing_rows
# In this case in the first vector(rownames(sub_exprs)), there are some specific names of genes (or their versions), that are not in the other vector (merged_sel$SYMBOL) 

# As a got priorily results ("MMD2.1" "HBD.1"  "TEC.1") , I want to find 
View(merged_sel[merged_sel$SYMBOL %in% c("MMD2","HBD","TEC","MMD"),])

# Assign new names to the problematic genes in terms of their names
merged_sel[merged_sel$ENTREZID == 100187828 ,]$SYMBOL <- "HBD.1"
merged_sel[merged_sel$ENTREZID == 100505381 ,]$SYMBOL <- "MMD2.1"
merged_sel[merged_sel$ENTREZID == 100124696 ,]$SYMBOL <- "TEC.1"

sub_exprs[rownames(sub_exprs) %in% c("MMD2","HBD","TEC","MMD2.1","HBD.1","TEC.1"),]


# checking wheter now is everything alright
missing_rows <- setdiff(rownames(sub_exprs),merged_sel$SYMBOL)
missing_rows
missing_rows <- setdiff(merged_sel$SYMBOL,rownames(sub_exprs))
missing_rows

###
### Creation of (1 and 2 _trims-Average) column for diff_table
trim = levels(as.factor(sub_pdata$trim_term))[1]
trim
# Here I create a specific order in merged_sel, that will be the same as in difexp_exprs(taken from sub_exprs)
difexp_exprs = sub_exprs[which(rownames(sub_exprs) %in% merged_sel$SYMBOL),]
merged_sel <- merged_sel[match(rownames(difexp_exprs),merged_sel$SYMBOL),]
# Check If every element(gene name) matches between merged_sel and difexp_exprs
!(FALSE %in% (merged_sel$SYMBOL == rownames(difexp_exprs)))
# If TRUE, they match

trim_sample_names = sub_pdata[sub_pdata$trim_term == trim,]$arraydatafile_exprscolumnnames
#trim_sample_names

difexp_exprs_trim = difexp_exprs[,which(colnames(difexp_exprs) %in% trim_sample_names)]

difexp_exprs_trim
# the same as previous func
#difexp_exprs_trim = difexp_exprs[,trim_sample_names]

merged_sel[,paste(trim,"Average",sep = " ")] <- rowMeans(difexp_exprs_trim)
#View(merged_sel)


trim = levels(as.factor(sub_pdata$trim_term))[2]
trim
difexp_exprs = sub_exprs[which(rownames(sub_exprs) %in% merged_sel$SYMBOL),]
!(FALSE %in% (merged_sel$SYMBOL == rownames(difexp_exprs)))
trim_sample_names = sub_pdata[sub_pdata$trim_term==trim,]$arraydatafile_exprscolumnnames

difexp_exprs_trim = difexp_exprs[,which(colnames(difexp_exprs) %in% trim_sample_names)]
merged_sel[,paste(trim,"Average",sep = " ")] = rowMeans(difexp_exprs_trim)
View(merged_sel)



# writing prepared and annotated files for further analysis
library("xlsx")
library("readxl")
write.xlsx(merged_sel,file.path(DataFilesFolder,"difexp_1-2.xlsx"))
write.xlsx(sub_exprs, file.path(DataFilesFolder,"sub_exprs_mapped_1-2.xlsx"))

```

## Reading and preparing Expression Matrix, Differential Expression Table 
```{r Read_Prepare ExprM, DiffExprTable}
# Reading Expression Matrix (ub_exprs_mapped_1-2.xlsx that is sub_expr from file), after I processed it 
expression <- read_excel(file.path(DataFilesFolder,"sub_exprs_mapped_1-2.xlsx"), sheet = "Sheet1")
expression <- as.data.frame(expression)
#class(expression)
# transfer names of genes from first column to rownames in df, and deleting them from 1 columns
rownames(expression) <- expression[, 1]
expression <- expression[-1]
View(expression)

# 1_2_metadata.tsv is sub_sub_P-data from file
metadata <- read.table(file.path(DataFilesFolder,"1_2_metadata.tsv"), header = TRUE, sep = "\t")
View(metadata)

# Reading diff_expr table (difexp_1-2.xlsx)
Dif_Expr <- read_excel(file.path(DataFilesFolder,"difexp_1-2.xlsx"), sheet = "Sheet1")
# Remove the first column from the data frame
Dif_Expr <- Dif_Expr[-1]
nrow(Dif_Expr)
# filter DEGs
DEGs <- Dif_Expr[(Dif_Expr$logFC > 0 | Dif_Expr$logFC < 0 ) & Dif_Expr$adj.P.Val < 0.05, ]
DEGs
# put DEGS in decreasing order 
DEGs <- DEGs[order(DEGs$logFC, decreasing = TRUE),]

```

## Principal Component Analysis

```{r PCA}

## PCA
pca <- prcomp(
  t(expression), # transpose our data frame to obtain PC scores for samples, not genes
  scale = TRUE # we want the data scaled to have unit variance for each gene
)
#str(pca)
#head(pca$x[, 1:5])
pca_summary <- summary(pca)
#pca_summary
# Now access the importance information for the first 5 PCs
pca_summary$importance[, 1:5]

# Make the first two PCs into a data frame for plotting with `ggplot2`
pca_df <- data.frame(pca$x[, 1:2]) %>%
  # Turn samples IDs stored as row names into a column
  tibble::rownames_to_column("arraydatafile_exprscolumnnames") %>%
  # Bring only the variables that we want from the metadata into this data frame
  # here we are going to join by `refinebio_accession_code` values
  dplyr::inner_join(
    dplyr::select(metadata, arraydatafile_exprscolumnnames,Gestational.Age.Appr ,Combined.Fetus.Sex ,trim_term, secondaryaccession),
    by = "arraydatafile_exprscolumnnames" )

pca_df

pca_df$Sample_Name <- paste0(substr(pca_df$arraydatafile_exprscolumnnames,1,9),"_",
                                  pca_df$Gestational.Age.Appr)

#rm(pca_df)
#metadata$Gestational.Age.Appr
#pca_summary$importance[2, 1:2]

PC1_2_pVar <- unname(c(pca_summary$importance[2, 1:2]))
PC1_2_pVar
# Make a scatterplot using `ggplot2` functionality
pca_plot <- ggplot(
  pca_df,
  aes(
    x = PC1,
    y = PC2,
    color = trim_term, # label points with different colors for each `subgroup`
    shape = Combined.Fetus.Sex
  )
) +
  geom_point(size = 4) + # Plot individual points to make a scatterplot
  geom_text(aes(label = Gestational.Age.Appr),vjust = -0.6 ) +
  theme_classic() +# Format as a classic-looking plot with no gridlines
  labs(x = paste("PC1 (", PC1_2_pVar[1]*100, "%)", sep = ""),
       y = paste("PC2 (", PC1_2_pVar[2]*100, "%)", sep = ""))
# Print out the plot here
pca_plot

# plot with secondaryaccession instead of trim_term
pca_plot <- ggplot(
  pca_df,
  aes(
    x = PC1,
    y = PC2,
    color = secondaryaccession, # label points with different colors for each `subgroup`
    shape = trim_term
  )
) +
  geom_point(size = 4) + # Plot individual points to make a scatterplot
#  geom_text(aes(label = Gestational.Age.Appr),vjust = -0.9 ) +
  geom_text(aes(label = Sample_Name),vjust = 2 ) +
  theme_classic() +# Format as a classic-looking plot with no gridlines
  labs(x = paste("PC1 (", PC1_2_pVar[1]*100, "%)", sep = ""),
       y = paste("PC2 (", PC1_2_pVar[2]*100, "%)", sep = ""))
# Print out the plot here
pca_plot


```

## HEATMAP Creation

```{r Heatmaps}
#### HEATMAP Creation

library(ComplexHeatmap)
library(RColorBrewer)
library(dplyr)

View(metadata)
# creation of adjusted metadata, where I have additional variable Sample_Name(shortened version of arraydatafile_exprscolumnnames, + Gestational Age)
metadata_adj <- metadata
metadata_adj$Sample_Name <- paste0(substr(metadata$arraydatafile_exprscolumnnames,1,9),"_",
                                  metadata$Gestational.Age.Appr)

metadata_adj                                  
# Assuming 'DEGs' is my original dataframe
# Get the first 30 rows
first_30 <- DEGs[1:30, ]

# Get the last 30 rows
last_30 <- DEGs[(nrow(DEGs) - 29) : nrow(DEGs), ]

# Combine the first and last 30 rows into a new dataframe
combined_df <- rbind(first_30, last_30)
combined_df
# Now 'combined_df' contains the first 30 and last 30 rows of 'DEGs'


scaled_counts<- t(apply(expression, 1, scale)) #center and scale each column (Z-score) then transpose
scaled_counts[combined_df$SYMBOL,]
#View(scaled_counts)
scaled_counts
colnames(scaled_counts) <- metadata_adj$Sample_Name

  
heatmap <- HeatmapAnnotation(
  Condition = metadata$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
  ) %>%
    Heatmap(
      scaled_counts[combined_df$SYMBOL,],
      cluster_rows = TRUE,
      column_labels = colnames(scaled_counts),
      name = "Z-score",
      cluster_columns = TRUE,
      top_annotation = .,
      show_column_names = TRUE,
      show_row_names = TRUE, # in this case I used 1000 Top Up_regs and 1000 Donw_regs
      column_title = "First and second trimestr comparison"
    )
  
heatmap


# heatmap of 1000 top UP and 100 Down regulated
first_1000 <- DEGs[1:1000, ]
last_1000 <- DEGs[(nrow(DEGs) - 999) : nrow(DEGs), ]
combined_df1 <- rbind(first_1000, last_1000)


heatmap <- HeatmapAnnotation(
  Condition = metadata$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
  ) %>%
    Heatmap(
      scaled_counts[combined_df1$SYMBOL,],
      cluster_rows = TRUE,
      column_labels = colnames(scaled_counts),
      name = "Z-score",
      cluster_columns = TRUE,
      top_annotation = .,
      show_column_names = TRUE,
      show_row_names = FALSE, # in this case I used 1000 Top Up_regs and 1000 Donw_regs
      column_title = "First and second trimestr comparison"
    )
heatmap



heatmap <- HeatmapAnnotation(
  Trimestr = metadata$trim_term,  # Use the 'condition' column as annotation data
  Sex = metadata$Combined.Fetus.Sex,
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df$SYMBOL],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_column_names = TRUE,
    show_row_names = TRUE,
    column_title = "First and second trimestr comparison"
  )
heatmap


# Gestational.Age
heatmap <- HeatmapAnnotation(
  Condition = metadata_adj$Gestational.Age.Appr,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df1$SYMBOL,],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_row_names = TRUE,
    show_column_names = TRUE,
  )
heatmap


# boys heatmap
metadata_boys <- metadata[metadata$Combined.Fetus.Sex == "Male",]
metadata_boys_samples <- c(metadata_boys$arraydatafile_exprscolumnnames)
metadata_boys_samples
expression
colnames(metadata_boys_samples)
expression_boys <- expression[colnames(expression) %in% metadata_boys_samples]
#expression_boys

#expression
#View(expression)
scaled_counts<- t(apply(expression_boys, 1, scale)) #center and scale each column (Z-score) then transpose
scaled_counts[combined_df$SYMBOL,]
#View(scaled_counts)

scaled_counts
colnames(scaled_counts) <- colnames(expression_boys)


heatmap <- HeatmapAnnotation(
  Condition = metadata_boys$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df$SYMBOL,],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_column_names = FALSE
  )

heatmap


metadata_girls <- metadata[metadata$Combined.Fetus.Sex == "Female",]
metadata_girls_samples <- c(metadata_girls$arraydatafile_exprscolumnnames)
metadata_girls_samples
expression
colnames(metadata_girls_samples)
expression_girls <- expression[colnames(expression) %in% metadata_girls_samples]
#expression_boys

#expression
#View(expression)
scaled_counts<- t(apply(expression_girls, 1, scale)) #center and scale each column (Z-score) then transpose
scaled_counts[combined_df$SYMBOL,]
#View(scaled_counts)

scaled_counts
colnames(scaled_counts) <- colnames(expression_girls)


heatmap <- HeatmapAnnotation(
  Condition = metadata_girls$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df$SYMBOL,],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_column_names = FALSE
  )
heatmap
```

## Overrepresented analysis, ORA, Results


```{r ORA, + Results}

###
#### Overrepresentation analysis ORA 
#
# Read in the data
df <- read_excel("difexp_1-2.xlsx", sheet = "Sheet1")
#df <- read.csv(paste0(in_path, 'expression2.csv'), row.names = 1)

# Remove the first column from the data frame
df <- df[-1]
#View(df)


original_gene_list <- df$logFC
names(original_gene_list) <- df$SYMBOL
original_gene_list
# omit any NA values 
gene_list <- na.omit(original_gene_list)
gene_list = sort(gene_list, decreasing = TRUE)

#gene_list
#df_2_4_7_8 <- df[,c(1,4,7,8)]
#View(df_2_4_7_8)

# Annotate according to differential expression
# I can use different paramaters, lile logFC> 0 or logFC >1
df <- df %>% mutate(diffexpressed = case_when(
  logFC > 1 & adj.P.Val < 0.05 ~ 'All',
  logFC < -1 & adj.P.Val < 0.05 ~ 'All',
  adj.P.Val > 0.05 ~ 'NO'
))
df


# Get the genes that are present in your dataframe
genes_in_data <- df$SYMBOL
genes_in_data
# Read in the .gmt file
file <- "BP_subset_GO_Hs.symbols.gmt"
pwl2 <- read.gmt(file) 
View(pwl2)
# Subset to the genes that are present in our dataset
pwl2 <- pwl2[pwl2$gene %in% genes_in_data,] 
View(pwl2)
# Save the filtered background gene set
filename <- 'GO_BP.RDS'
saveRDS(pwl2, filename)

##### SQUIDTIP! If you want to parse several .gmt files at once, you can use a loop:
#
#gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
#for (file in gmt_files){
#  file <- gmt_files[1]
#  pwl2 <- read.gmt(file) 
#  pwl2 <- pwl2[pwl2$gene %in% genes_in_data,]
#  filename <- paste(gsub('c.\\.', '', gsub('.v7.5.*$', '', file)), '.RDS', sep = '')
#  saveRDS(pwl2, filename)
#}
#####
# Remove non-significant genes
#View(df_DifExrp)
df <- df[df$diffexpressed != 'NO', ]
# Substitute names so they are annotated nicely in the heatmap later
#df_DifExrp$diffexpressed <- gsub('DOWN', 'Healthy', gsub('UP', 'Severe', df_DifExrp$diffexpressed))
View(df)
unique(df$diffexpressed)
# Split the dataframe into a list of sub-dataframes: upregulated, downregulated genes
deg_results_list <- split(df, df$diffexpressed)
#View(deg_results_list)

## Run ClusterProfiler -----------------------------------------------
# Settings
out_path <- "/Users/RTIntelektFBT/Desktop/Roman_Project/try_from_almostZERO"
name_of_comparison <- '2-1_trimestrs' # for our filename
background_genes <- 'Biological_processes_GO' # for our filename
bg_genes <- readRDS('GO_BP.RDS') # read in the background genes
#View(bg_genes)
padj_cutoff <- 0.05 # p-adjusted threshold, used to filter out pathways
genecount_cutoff <- 5 # minimum number of genes in the pathway, used to filter out pathways
filename <- paste0(out_path, 'clusterProfiler/', name_of_comparison, '_', background_genes) # filename of our PEA results
##### SQUIDTIP! An option to read in your background genes by only defining your 'background_genes' variable
#if(background_genes == 'KEGG'){
#  bg_genes <- readRDS(paste0(bg_path, 'kegg.RDS'))
#} else if(background_genes == 'reactome'){
#  bg_genes <- readRDS(paste0(bg_path, 'reactome.RDS'))
#} else if(background_genes == 'go.bp'){
#  bg_genes <- readRDS(paste0(bg_path, 'go.bp.RDS'))
#} else {
#  stop('Invalid background genes. Select one of the following: KEGG, Reactome, GO, or add new pwl to function')
#}
####
#View(deg_results_list)
#View(bg_genes)
unique(bg_genes$gene)
deg_results_list[1]



# Run clusterProfiler on each sub-dataframe
View(deg_results_list)
res <- lapply(names(deg_results_list),
              function(x) enricher(gene = deg_results_list[[x]]$SYMBOL,
                                   TERM2GENE = bg_genes))
View(res)
names(res) <- names(deg_results_list)
#Convert the list of enrichResults for each sample_pattern to a dataframe with the pathways
res_df <- lapply(names(res), function(x) rbind(res[[x]]@result))
names(res_df) <- names(res)

res_df <- do.call(rbind, res_df)
#head(res_df)
View(res_df)


res_df <- res_df %>% mutate(minuslog10padj = -log10(p.adjust),
                            diffexpressed = gsub('\\.GOBP.*$|\\.KEGG.*$|\\.REACTOME.*$', '', rownames(res_df)))

View(res_df)

# Subset to those pathways that have p adj < cutoff and gene count > cutoff (you can also do this in the enricher function)
target_pws <- unique(res_df$ID[res_df$p.adjust < padj_cutoff & res_df$Count > genecount_cutoff]) # select only target pathways have p adjusted < 0.05 and at least 6 genes
target_pws
length(res_df$ID)
length(target_pws)
res_df <- res_df[res_df$ID %in% target_pws, ]
View(res_df)

# Save clusterprofiler results
write.csv(res_df, "2-1_trim_resclusterp.csv", row.names = FALSE)

#df_res_df_sign <- res_df_sign[res_df_sign$Description == "GOBP_MITOCHONDRIAL_TRANSLATION",]
#View(df_res_df_sign)


### For visualisation

#install.packages('pheatmap')
#install.packages("DOSE")
#install.packages("enrichplot")
#install.packages("ggupset")
library(pheatmap)
library(DOSE)
library(enrichplot)
library(ggupset)

# Read in the data
res_df <- read.csv('2-1_trim_resclusterp.csv')
View(res_df)
#res_df_sign_i <- res_df_sign[,1:11]
#View(res_df_sign_i)

bg_genes <- readRDS('GO_BP.RDS')
View(bg_genes)
#bg_genes$term <- as.character(bg_genes$term)

# Convert clusterProfiler object to a new "enrichResult" object
# Select only upregulated genes in Severe
#View(res_df)
# I wanna try all genes, not only UP regulated
res_df <- res_df %>% filter(diffexpressed == 'All') %>% 
  dplyr::select(!c('minuslog10padj', 'diffexpressed')) 

#res_df <- res_df %>% dplyr::select(!c('minuslog10padj', 'diffexpressed')) 

# the next is already done
#rownames(res_df) <- res_df$ID
# For visualisation purposes, let's shorten the pathway names
res_df$Description <- gsub('(H|h)iv', 'HIV', 
                           gsub('pd 1', 'PD-1',
                                gsub('ecm', 'ECM', 
                                     gsub('(I|i)nterleukin', 'IL', 
                                          gsub('(R|r)na', 'RNA', 
                                               gsub('(D|d)na', 'DNA',
                                                    gsub(' i ', ' I ', 
                                                         gsub('(A|a)tp ', 'ATP ', 
                                                              gsub('(N|n)adh ', 'NADH ', 
                                                                   gsub('(N|n)ad ', 'NAD ',
                                                                        gsub('t cell', 'T cell',
                                                                             gsub('b cell', 'B cell',
                                                                                  gsub('built from .*', ' (...)',
                                                                                       gsub('mhc', 'MHC',
                                                                                            gsub('mhc class i', 'MHC I', 
                                                                                                 gsub('mhc class ii', 'MHC II', 
                                                                                                      stringr::str_to_sentence(
                                                                                                        gsub('_', ' ',  
                                                                                                             gsub('GOBP_|KEGG_|REACTOME_', '', res_df$Description)))))))))))))))))))



#View(genes_in_data)
#is.character(genes_in_data)
rownames(res_df) <- res_df$ID 
View(res_df)

enrichres <- new("enrichResult",
                 readable = FALSE,
                 result = res_df,
                 pvalueCutoff = 0.05,
                 pAdjustMethod = "BH",
                 qvalueCutoff = 0.2,
                 organism = "human",
                 ontology = "BP",
                 gene = df$SYMBOL,
                 keytype = "SYMBOL",
                 universe = unique(bg_genes$gene),
                 gene2Symbol = character(0),
                 geneSets = bg_genes)

class(enrichres)

# Barplot
barplot_20 <- barplot(enrichres, showCategory = 20) 
barplot_20
mutate(enrichres, qscore = -log(p.adjust, base = 10)) %>% 
  barplot(x = "qscore")
barplot_path <- "/enrichment/barplot.png"
ggsave(barplot_path,barplot_20)

# Dotplot
dotplot(enrichres, showCategory = 15) + ggtitle("Up-Down_regulated")

# Cnetplot
cnetplot(enrichres)
cnetplot(enrichres, categorySize="pvalue",foldChange = gene_list, showCategory=8)

goplot(enrichres)

View(enrichres)

# Heatplot
heatplot(enrichres, showCategory = 5)

# Treeplot
enrichres2 <- pairwise_termsim(enrichres) # calculate pairwise similarities of the enriched terms using Jaccard’s similarity index
#treeplot(enrichres2)

# Enrichment map 
emapplot(enrichres2)

# Upsetplot
upsetplot(enrichres)


```











