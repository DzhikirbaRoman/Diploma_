---
title: "Diploma"
author: "Dzhikirba Roman"
date: "2024-03-30"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Set up working directory and for Data Files, Plots
Here I need to set working directory and for data files in it
```{r set dir}
getwd()
working_dir <- "C:/Users/RTIntelektFBT/Desktop/Roman_Project/Diploma_"
setwd(working_dir)
DataFilesFolder <- file.path(working_dir,"Data_Files")
PlotsFolder <- file.path(working_dir,"Plots")
```
## Data reading - Expression matrix and metaData 

```{r Data reading}
# Meta Data
sub_pdata = read.table(file.path(DataFilesFolder,"sub_sub_pdata.tsv"), sep="\t", header = TRUE)
head(sub_pdata)
# Check how many samples I have from 1 and 2 trimestrs
table(sub_pdata[,c( "trim_term")])

#as.factor(sub_pdata$trim_term)
#sub_pdata$trim_term


# expression matrix
sub_exprs = read.table(file.path(DataFilesFolder,"sub_exprs.tsv"), sep="\t")
head(sub_exprs)
# Here I substitute colnames with trimmed versions of Sample names + Gestational.Age 
colnames(sub_exprs)

# If True, I can substitite rownames for sub_expr, that will contain trimmed Sample names + Gestational.Age
#sub_pdata$arraydatafile_exprscolumnnames == colnames(sub_exprs)

colnames(sub_exprs)
colnames(sub_exprs) <- paste0(substr(sub_pdata$arraydatafile_exprscolumnnames,1,10),"_",
                                  sub_pdata$Gestational.Age.Appr)
colnames(sub_exprs)

# Do the same for sub_pdata
sub_pdata$arraydatafile_exprscolumnnames <- paste0(substr(sub_pdata$arraydatafile_exprscolumnnames,1,10),"_",
                                  sub_pdata$Gestational.Age.Appr)

#sub_pdata$arraydatafile_exprscolumnnames
```
## Building heatmap using pheatmap
* Unsupervised analysis is a good way to get an understanding of the sources of variation in the data. It can also identify potential outlier samples.

The function cor() can calculate the correlation (on scale 0 - 1) in a pairwise fashion between all samples. This can be then visualised on a heatmap. Among the many options for creating heatmaps in R, the pheatmap library is one of the more popular ones. The only argument it requires is a matrix of numerical values (such as the correlation matrix).
```{r pheatmaps. Sample correlation }
library(pheatmap)
library(tidyverse)
library(dplyr)
### pheatmap for both trimestrs
# here i want to create df tsampleinfo hat contains trims for sample names to put in as annotation in pheatmap()
sampleinfo <- dplyr::select(sub_pdata, trim_term, Combined.Fetus.Sex)
#class(sampleinfo)
# Here I add rownames for sampleinfo, that contain trimmed Sample names + Gestational.Age
rownames(sampleinfo) <- paste0(substr(sub_pdata$arraydatafile_exprscolumnnames,1,10),"_",
                                  sub_pdata$Gestational.Age.Appr)
View(sampleinfo)
# creation corMatrix for samples
corMatrix <- cor(sub_exprs,use="c")
pheatmap(corMatrix, width = 300, height = 900, annotation_col = sampleinfo)     

# first trim
names_1trim <- rownames(sampleinfo[sampleinfo$trim_term == "First Trimester",])
names_1trim

corMatrix_1trim <- cor(sub_exprs[,names_1trim],use="c")
pheatmap(corMatrix_1trim, width = 300, height = 900 )     

# second trim
names_2trim <- rownames(sampleinfo[sampleinfo$trim_term == "Second Trimester",])
names_2trim
corMatrix_2trim <- cor(sub_exprs[,names_2trim],use="c")
pheatmap(corMatrix_2trim, width = 300, height = 900 )     

```


## Building Differential Expression table
By far the most-popular package for performing differential expression is limma. The user-guide is extensive and covers the theory behind the analysis and many use-cases (Chapters 9 and 17 for single-channel data such as Illumina and Affymetrix)

[Link for tutorial](https://sbc.shef.ac.uk/geo_tutorial/tutorial.nb.html#Sample_clustering_and_Principal_Components_Analysis)
```{r Differential expression}
library(limma)

# Crucially, we have to allocate the samples in our dataset to the sample groups of interest. A useful function is model.matrix, which will create a design matrix from one of the columns in your sub_pdata Here I choose sub_pdata$trim_term

fit_mod <- model.matrix(~ 0 + as.factor(sub_pdata$trim_term), data = sub_pdata)
fit_mod
## the column names are a bit ugly, so we will rename 
colnames(fit_mod) = c('trim1','trim2')
fit_mod

# The lmFit function is used to fit the model to the data. The result of which is to estimate the expression level in each of the groups that we specified.
fit <- lmFit(sub_exprs, fit_mod)  # fit each probeset to model
fit
#medians <- apply(sub_exprs, 1, median)
#medians

# In order to perform the differential analysis, we have to define the contrast that we are interested in. In our case we only have two groups and one contrast of interest. Multiple contrasts can be defined in the makeContrasts function.
contrast.matrix <- makeContrasts(trim1 - trim2, levels = fit_mod)

## can define multiple contrasts
## e.g. makeContrasts(Group1 - Group2, Group2 - Group3,....levels=design)
# contrasts.fit() Given a linear model fit to microarray data, compute estimated coefficients and standard errors for a given set of contrasts.
fit2 <- contrasts.fit(fit = fit, contrasts =contrast.matrix)
#fit2

#Finally, apply the empirical Bayes’ step to get our differential expression statistics and p-values.
efit <- eBayes(fit2)        # empirical Bayes adjustment
#View(efit)

# The topTable function automatically displays the results for the first contrast
diff_table = topTable(efit, number = nrow(sub_exprs))
nrow(diff_table)
#If we want to know how many genes are differentially-expressed overall we can use the decideTests function.
#decideTests(efit)
diff_table
#nrow(d)

```

## Obtaining Annotation such as ("ENTREZID","GENENAME") via org.Hs.eg.db, and calculating means of gene expre for 1 and 2 trimestrs 
```{r Obtaining Annotation}
library(org.Hs.eg.db)
#keys(org.Hs.eg.db)
#keytypes(org.Hs.eg.db)
#View(sub_exprs)

### Annotation of genes for diff_table
sel = AnnotationDbi::select(org.Hs.eg.db, rownames(diff_table), columns = c("ENTREZID","GENENAME"), keytype="SYMBOL")
sel
# Filtering out Genes, that were not annotated
sel = sel[!is.na(sel$ENTREZID),]

### Annotation of genes for sub_exprs(expression matrix)
sel2 = AnnotationDbi::select(org.Hs.eg.db, rownames(sub_exprs), columns =  c("ENTREZID","GENENAME"), keytype="SYMBOL")
# Filtering out Genes, that were not annotated
sel2 = sel2[!is.na(sel2$ENTREZID),]

# Checking whether all our genes in Expr Matrix are represented in one copy
length(unique(rownames(sub_exprs))) == length(rownames(sub_exprs))
# Checking whether all our genes in sel2 are represented in one copy
length(sel2$ENTREZID) == length(unique(sel2$ENTREZID))

# Checking whether we have NA ENTREZID of genes in sel2
NA %in% sel2$ENTREZID

# Checking whether we have NA names of genes in sub_exprs
NA %in% rownames(sub_exprs)

sel2
sub_exprs
# Filtering out Genes that were not annotated in Expression Matrix(sub_exprs)
sub_exprs <- sub_exprs[sel2$SYMBOL,]
#View(sub_exprs)

# Checking we have the same of lengths for genes in sel2 and Expression Matrix(sub_exprs)
nrow(sub_exprs)== nrow(sel2)

# Checking we have the same genes in sel2 and in Expression Matrix(sub_exprs)
rownames(sub_exprs) == sel2$SYMBOL

# Checking whether we have FALSE, that means that not all genes names from sub_exprs and sel2 are the same
!(FALSE %in% (rownames(sub_exprs) == sel2$SYMBOL))
# we have FALSE
# it is true when rownames(sub_exprs) = sel2$SYMBOL 

nrow(diff_table)


#View(sel)
#View(diff)
nrow(sel)
nrow(diff_table)

# with merge function we obtain new diff_table where there are only annotated genes, those who were not annotated will be discarded. As result, we obtain diff_table with less number of rows
merged_sel = merge(sel,diff_table, by.x = "SYMBOL", by.y = "row.names")
merged_sel

nrow(merged_sel) == nrow(sub_exprs)

#View(merged_sel)

length(levels(as.factor(sub_pdata$trim_term)))

?which
# Check the length of sub_exprs. If the length is different from one that was previosly, It means some genes have the same names 
difexp_exprs1 = sub_exprs[which(rownames(sub_exprs) %in% merged_sel$SYMBOL),]
nrow(sub_exprs)
nrow(difexp_exprs1)

#rownames(merged_sel)
length(merged_sel$SYMBOL)
length(rownames(sub_exprs))

#View(merged_sel)
# The setdiff() function in R is used to find the set difference between two vectors or sets. It returns the elements that are present in the first vector but not present in the second vector.
missing_rows <- setdiff(rownames(sub_exprs),merged_sel$SYMBOL)
missing_rows
missing_rows <- setdiff(merged_sel$SYMBOL,rownames(sub_exprs))
missing_rows
# In this case in the first vector(rownames(sub_exprs)), there are some specific names of genes (or their versions), that are not in the other vector (merged_sel$SYMBOL) 

# As a got priorily results ("MMD2.1" "HBD.1"  "TEC.1") , I want to find 
View(merged_sel[merged_sel$SYMBOL %in% c("MMD2","HBD","TEC","MMD"),])

# Assign new names to the problematic genes in terms of their names
merged_sel[merged_sel$ENTREZID == 100187828 ,]$SYMBOL <- "HBD.1"
merged_sel[merged_sel$ENTREZID == 100505381 ,]$SYMBOL <- "MMD2.1"
merged_sel[merged_sel$ENTREZID == 100124696 ,]$SYMBOL <- "TEC.1"

sub_exprs[rownames(sub_exprs) %in% c("MMD2","HBD","TEC","MMD2.1","HBD.1","TEC.1"),]


# checking wheter now is everything alright
missing_rows <- setdiff(rownames(sub_exprs),merged_sel$SYMBOL)
missing_rows
missing_rows <- setdiff(merged_sel$SYMBOL,rownames(sub_exprs))
missing_rows

###
### Creation of (1 and 2 _trims-Average) column for diff_table
trim = levels(as.factor(sub_pdata$trim_term))[1]
trim
# Here I create a specific order in merged_sel, that will be the same as in difexp_exprs(taken from sub_exprs)
difexp_exprs = sub_exprs[which(rownames(sub_exprs) %in% merged_sel$SYMBOL),]
merged_sel <- merged_sel[match(rownames(difexp_exprs),merged_sel$SYMBOL),]
# Check If every element(gene name) matches between merged_sel and difexp_exprs
!(FALSE %in% (merged_sel$SYMBOL == rownames(difexp_exprs)))
# If TRUE, they match

trim_sample_names = sub_pdata[sub_pdata$trim_term == trim,]$arraydatafile_exprscolumnnames
#trim_sample_names

difexp_exprs_trim = difexp_exprs[,which(colnames(difexp_exprs) %in% trim_sample_names)]

difexp_exprs_trim
# the same as previous func
#difexp_exprs_trim = difexp_exprs[,trim_sample_names]

merged_sel[,paste(trim,"Average",sep = " ")] <- rowMeans(difexp_exprs_trim)
#View(merged_sel)


trim = levels(as.factor(sub_pdata$trim_term))[2]
trim
difexp_exprs = sub_exprs[which(rownames(sub_exprs) %in% merged_sel$SYMBOL),]
!(FALSE %in% (merged_sel$SYMBOL == rownames(difexp_exprs)))
trim_sample_names = sub_pdata[sub_pdata$trim_term==trim,]$arraydatafile_exprscolumnnames

difexp_exprs_trim = difexp_exprs[,which(colnames(difexp_exprs) %in% trim_sample_names)]
merged_sel[,paste(trim,"Average",sep = " ")] = rowMeans(difexp_exprs_trim)
View(merged_sel)



# writing prepared and annotated files for further analysis
library("xlsx")
library("readxl")
write.xlsx(merged_sel,file.path(DataFilesFolder,"difexp_1-2.xlsx"))
write.xlsx(sub_exprs, file.path(DataFilesFolder,"sub_exprs_mapped_1-2.xlsx"))

```

## Reading and preparing Expression Matrix, Differential Expression Table 
```{r Read_Prepare ExprM, DiffExprTable}
# Reading Expression Matrix (ub_exprs_mapped_1-2.xlsx that is sub_expr from file), after I processed it 
expression <- read_excel(file.path(DataFilesFolder,"sub_exprs_mapped_1-2.xlsx"), sheet = "Sheet1")
expression <- as.data.frame(expression)
#class(expression)
# transfer names of genes from first column to rownames in df, and deleting them from 1 columns
rownames(expression) <- expression[, 1]
expression <- expression[-1]
View(expression)

# 1_2_metadata.tsv is sub_sub_P-data from file
#metadata <- read.table(file.path(DataFilesFolder,"1_2_metadata.tsv"), header = TRUE, sep = "\t")
metadata <- sub_pdata
View(metadata)

# Reading diff_expr table (difexp_1-2.xlsx)
Dif_Expr <- read_excel(file.path(DataFilesFolder,"difexp_1-2.xlsx"), sheet = "Sheet1")
# Remove the first column from the data frame
Dif_Expr <- Dif_Expr[-1]
nrow(Dif_Expr)
# filter DEGs
DEGs <- Dif_Expr[(Dif_Expr$logFC > 0 | Dif_Expr$logFC < 0 ) & Dif_Expr$adj.P.Val < 0.05, ]
DEGs
# put DEGS in decreasing order 
DEGs <- DEGs[order(DEGs$logFC, decreasing = TRUE),]

```

## Principal Component Analysis

```{r PCA}

## PCA
pca <- prcomp(
  t(expression), # transpose our data frame to obtain PC scores for samples, not genes
  scale = TRUE # we want the data scaled to have unit variance for each gene
)
#str(pca)
#head(pca$x[, 1:5])
pca_summary <- summary(pca)
#pca_summary
# Now access the importance information for the first 5 PCs
pca_summary$importance[, 1:5]

# Make the first two PCs into a data frame for plotting with `ggplot2`
pca_df <- data.frame(pca$x[, 1:2]) %>%
  # Turn samples IDs stored as row names into a column
  tibble::rownames_to_column("arraydatafile_exprscolumnnames") %>%
  # Bring only the variables that we want from the metadata into this data frame
  # here we are going to join by `refinebio_accession_code` values
  dplyr::inner_join(
    dplyr::select(metadata, arraydatafile_exprscolumnnames,Gestational.Age.Appr ,Combined.Fetus.Sex ,trim_term, secondaryaccession),
    by = "arraydatafile_exprscolumnnames" )

pca_df

pca_df$Sample_Name <- paste0(substr(pca_df$arraydatafile_exprscolumnnames,1,9),"_",
                                  pca_df$Gestational.Age.Appr)

#rm(pca_df)
#metadata$Gestational.Age.Appr
#pca_summary$importance[2, 1:2]

PC1_2_pVar <- unname(c(pca_summary$importance[2, 1:2]))
PC1_2_pVar
# Make a scatterplot using `ggplot2` functionality
pca_plot <- ggplot(
  pca_df,
  aes(
    x = PC1,
    y = PC2,
    color = trim_term, # label points with different colors for each `subgroup`
    shape = Combined.Fetus.Sex
  )
) +
  geom_point(size = 4) + # Plot individual points to make a scatterplot
  geom_text(aes(label = Gestational.Age.Appr),vjust = -0.6 ) +
  theme_classic() +# Format as a classic-looking plot with no gridlines
  labs(x = paste("PC1 (", PC1_2_pVar[1]*100, "%)", sep = ""),
       y = paste("PC2 (", PC1_2_pVar[2]*100, "%)", sep = ""))
# Print out the plot here
pca_plot

# plot with secondaryaccession instead of trim_term
pca_plot <- ggplot(
  pca_df,
  aes(
    x = PC1,
    y = PC2,
    color = secondaryaccession, # label points with different colors for each `subgroup`
    shape = trim_term
  )
) +
  geom_point(size = 4) + # Plot individual points to make a scatterplot
#  geom_text(aes(label = Gestational.Age.Appr),vjust = -0.9 ) +
  geom_text(aes(label = Sample_Name),vjust = 2 ) +
  theme_classic() +# Format as a classic-looking plot with no gridlines
  labs(x = paste("PC1 (", PC1_2_pVar[1]*100, "%)", sep = ""),
       y = paste("PC2 (", PC1_2_pVar[2]*100, "%)", sep = ""))
# Print out the plot here
pca_plot


```

## HEATMAP Creation

```{r Heatmaps}
#### HEATMAP Creation

library(ComplexHeatmap)
library(RColorBrewer)
library(dplyr)

View(metadata)
# creation of adjusted metadata, where I have additional variable Sample_Name(shortened version of arraydatafile_exprscolumnnames, + Gestational Age)
metadata_adj <- metadata
metadata_adj$Sample_Name <- paste0(substr(metadata$arraydatafile_exprscolumnnames,1,9),"_",
                                  metadata$Gestational.Age.Appr)

metadata_adj                                  
# Assuming 'DEGs' is my original dataframe
# Get the first 30 rows
first_30 <- DEGs[1:30, ]

# Get the last 30 rows
last_30 <- DEGs[(nrow(DEGs) - 29) : nrow(DEGs), ]

# Combine the first and last 30 rows into a new dataframe
combined_df <- rbind(first_30, last_30)
combined_df
# Now 'combined_df' contains the first 30 and last 30 rows of 'DEGs'


scaled_counts<- t(apply(expression, 1, scale)) #center and scale each column (Z-score) then transpose
scaled_counts[combined_df$SYMBOL,]
#View(scaled_counts)
scaled_counts
colnames(scaled_counts) <- metadata_adj$Sample_Name

  
heatmap <- HeatmapAnnotation(
  Condition = metadata$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
  ) %>%
    Heatmap(
      scaled_counts[combined_df$SYMBOL,],
      cluster_rows = TRUE,
      column_labels = colnames(scaled_counts),
      name = "Z-score",
      # border = "black",
      cluster_columns = TRUE,
      top_annotation = .,
      show_column_names = TRUE,
      show_row_names = TRUE, # in this case I used 1000 Top Up_regs and 1000 Donw_regs
      column_title = "First and second trimestr comparison"
    )
  
heatmap



# heatmap of 1000 top UP and 100 Down regulated
first_1000 <- DEGs[1:1000, ]
last_1000 <- DEGs[(nrow(DEGs) - 999) : nrow(DEGs), ]
combined_df1 <- rbind(first_1000, last_1000)


heatmap <- HeatmapAnnotation(
  Condition = metadata$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
  ) %>%
    Heatmap(
      scaled_counts[combined_df1$SYMBOL,],
      cluster_rows = TRUE,
      column_labels = colnames(scaled_counts),
      name = "Z-score",
      cluster_columns = TRUE,
      top_annotation = .,
      show_column_names = TRUE,
      show_row_names = FALSE, # in this case I used 1000 Top Up_regs and 1000 Donw_regs
      column_title = "First and second trimestr comparison"
    )
heatmap

scaled_counts

heatmap <- HeatmapAnnotation(
  Trimestr = metadata$trim_term,  # Use the 'condition' column as annotation data
  Sex = metadata$Combined.Fetus.Sex,
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df$SYMBOL,],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_column_names = TRUE,
    show_row_names = TRUE,
    column_title = "First and second trimestr comparison"
  )
heatmap


# Gestational.Age
heatmap <- HeatmapAnnotation(
  Condition = metadata_adj$Gestational.Age.Appr,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df1$SYMBOL,],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_row_names = TRUE,
    show_column_names = TRUE,
  )
heatmap
?Heatmap

# boys heatmap
metadata_boys <- metadata[metadata$Combined.Fetus.Sex == "Male",]
metadata_boys_samples <- c(metadata_boys$arraydatafile_exprscolumnnames)
metadata_boys_samples
expression
colnames(metadata_boys_samples)
expression_boys <- expression[colnames(expression) %in% metadata_boys_samples]
#expression_boys

#expression
#View(expression)
scaled_counts<- t(apply(expression_boys, 1, scale)) #center and scale each column (Z-score) then transpose
scaled_counts[combined_df$SYMBOL,]
#View(scaled_counts)

scaled_counts
colnames(scaled_counts) <- colnames(expression_boys)


heatmap <- HeatmapAnnotation(
  Condition = metadata_boys$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df$SYMBOL,],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_column_names = FALSE
  )

heatmap


metadata_girls <- metadata[metadata$Combined.Fetus.Sex == "Female",]
metadata_girls_samples <- c(metadata_girls$arraydatafile_exprscolumnnames)
metadata_girls_samples
expression
colnames(metadata_girls_samples)
expression_girls <- expression[colnames(expression) %in% metadata_girls_samples]
#expression_boys

#expression
#View(expression)
scaled_counts<- t(apply(expression_girls, 1, scale)) #center and scale each column (Z-score) then transpose
scaled_counts[combined_df$SYMBOL,]
#View(scaled_counts)

scaled_counts
colnames(scaled_counts) <- colnames(expression_girls)


heatmap <- HeatmapAnnotation(
  Condition = metadata_girls$trim_term,  # Use the 'condition' column as annotation data
  col = list(Trimester = c("First Trimester" = "green", "Second Trimester" = "blue"))  # Define colors for annotation levels
) %>%
  Heatmap(
    scaled_counts[combined_df$SYMBOL,],
    cluster_rows = TRUE,
    column_labels = colnames(scaled_counts),
    name = "Z-score",
    cluster_columns = TRUE,
    top_annotation = .,
    show_column_names = FALSE
  )
heatmap
```
## Volcano Plot
```{r Volcano Plot}
#list.files(DataFilesFolder) 

de_genes <- read_excel(file.path(DataFilesFolder,"difexp_1-2.xlsx"))
# Remove the first column from the data frame
de_genes <- de_genes[-1]
library(ggrepel)
library(magrittr)
# View(de_genes)
# Create new variable for all genes to define whether they are significant or not, and make top 20 DOWN and UP regulated
de_genes$diffexpressed <- "Not Significant"
# Define what genes are UP-regulated
de_genes$diffexpressed[de_genes$logFC > 1 & de_genes$adj.P.Val < 0.05] <- "Up-regulated"
# Define what genes are DOWN-regulated
de_genes$diffexpressed[de_genes$logFC < -1 & de_genes$adj.P.Val < 0.05] <- "Down-regulated"
# Define Colors for different group of genes
my_colors <- c("black","blue","red","green","purple")
names(my_colors) <- c("Not Significant","Down-regulated","Up-regulated","Down-reg_top20","Up-reg_top20")

# create new variable to point Top 20 Pp and Down regulated DEGs
de_genes$delabel<- NA

# Creating new Pi-value for Volcano Plot that takes into account -log(adj.P.Val)*LogFC in order to arrange significant DEGs by this Value
de_genes$pi_value <- abs(-log10(de_genes$adj.P.Val)*de_genes$logFC)
#View(de_genes)

# Filter out all not significant genes and arrange them in ascending order
filtered_genes <- de_genes %>%
  filter(diffexpressed %in% c("Up-regulated","Down-regulated")) %>%
  arrange(desc(pi_value))
View(filtered_genes)
# Step of obtaining threshold for now Pi_value to indicate TOP 20 DEGs
threshold <- filtered_genes %>% slice(20) %>% pull(pi_value)
View(filtered_genes)
threshold
# Giving new values for diffexpressed variable for TOP 20 UP and Down regulated genes, that fit the threshold value
de_genes$diffexpressed[de_genes$pi_value >= threshold & de_genes$diffexpressed %in% c("Up-regulated")] <- "Up-reg_top20"
de_genes$diffexpressed[de_genes$pi_value >= threshold & de_genes$diffexpressed %in% c("Down-regulated")] <- "Down-reg_top20"
# Order again Genes in de_genes in acsending order by Pi_value
de_genes <- de_genes[order(de_genes$pi_value, decreasing = TRUE),]
de_genes

# Giving Names for TOP 20 Up and Down reg genes
de_genes$delabel[de_genes$diffexpressed %in% c("Up-reg_top20","Down-reg_top20")] <- de_genes$SYMBOL

View(de_genes)

plot1 <- ggplot(data = de_genes, aes(x = logFC, y = -log10(adj.P.Val), col = diffexpressed, label = delabel)) +
  geom_point() +
  theme_minimal() +
  geom_text_repel() +
  scale_color_manual(values = my_colors) +
  geom_vline(xintercept = c(-0.072,0.072,1,-1),col="red",linetype = 2) +
  geom_hline(yintercept = -log10(0.05246),col="red",linetype = 2) +
  theme(text = element_text(size = 20)) 
plot1

# Save the Plot
ggsave("Nice_Voclano_Plot.png",plot=plot1,width=10, height=8,path=PlotsFolder)

PlotsFolder
```

## Overrepresented analysis, ORA, Results

```{r ORA, + Results}
library(enrichplot)
library(clusterProfiler)
library(tidyverse)
###
#### Overrepresentation analysis ORA 
#
# Read in the data of difexp_1-2.xlsx (table of differential expression)
df <- read_excel("difexp_1-2.xlsx", sheet = "Sheet1")
#df <- read.csv(paste0(in_path, 'expression2.csv'), row.names = 1)

# Remove the first column from the data frame
df <- df[-1]
View(df)

# creation of gene list where I have logFC values for specific genes, I will use it for plotting
original_gene_list <- df$logFC
names(original_gene_list) <- df$SYMBOL
original_gene_list
# omit any NA values 
gene_list <- na.omit(original_gene_list)
gene_list = sort(gene_list, decreasing = TRUE)

#gene_list
#df_2_4_7_8 <- df[,c(1,4,7,8)]
#View(df_2_4_7_8)

# Annotate according to differential expression
# I can use different paramaters, lile logFC> 0 or logFC >1
# I can replace All with Up and Down regulated genes in case I want to explore about specific group of genes
df <- df %>% mutate(diffexpressed = case_when(
  logFC > 1 & adj.P.Val < 0.05 ~ 'All',
  logFC < -1 & adj.P.Val < 0.05 ~ 'All',
  adj.P.Val > 0.05 ~ 'NO'
))
df
View(df)

# Get the genes that are present in your dataframe
genes_in_data <- df$SYMBOL
genes_in_data
# Read in the .gmt file
file <- "BP_subset_GO_Hs.symbols.gmt"
pwl2 <- read.gmt(file) 
View(pwl2)
# Subset to the genes that are present in our dataset
pwl2 <- pwl2[pwl2$gene %in% genes_in_data,] 
View(pwl2)
# Save the filtered background gene set
filename <- 'GO_BP.RDS'
saveRDS(pwl2, filename)
 
##### If you want to parse several .gmt files at once, you can use a loop:
#
#gmt_files <- list.files(path = bg_path, pattern = '.gmt', full.names = TRUE)
#for (file in gmt_files){
#  file <- gmt_files[1]
#  pwl2 <- read.gmt(file) 
#  pwl2 <- pwl2[pwl2$gene %in% genes_in_data,]
#  filename <- paste(gsub('c.\\.', '', gsub('.v7.5.*$', '', file)), '.RDS', sep = '')
#  saveRDS(pwl2, filename)
#}
#####
# Remove non-significant genes
#View(df_DifExrp)
df <- df[df$diffexpressed != 'NO', ]
# Substitute names so they are annotated nicely in the heatmap later
#df_DifExrp$diffexpressed <- gsub('DOWN', 'Healthy', gsub('UP', 'Severe', df_DifExrp$diffexpressed))
View(df)
unique(df$diffexpressed)
# Split the dataframe into a list of sub-dataframes: upregulated, downregulated genes
deg_results_list <- split(df, df$diffexpressed)
#View(deg_results_list)

## Run ClusterProfiler -----------------------------------------------
# Settings
#getwd()
out_path <- "C:/Users/RTIntelektFBT/Desktop/Roman_Project/Diploma_"
name_of_comparison <- '2-1_trimestrs' # for our filename
background_genes <- 'Biological_processes_GO' # for our filename
bg_genes <- readRDS('GO_BP.RDS') # read in the background genes
#View(bg_genes)
padj_cutoff <- 0.05 # p-adjusted threshold, used to filter out pathways
genecount_cutoff <- 5 # minimum number of genes in the pathway, used to filter out pathways
filename <- paste0(out_path, 'clusterProfiler/', name_of_comparison, '_', background_genes) # filename of our PEA results
##### SQUIDTIP! An option to read in your background genes by only defining your 'background_genes' variable
#if(background_genes == 'KEGG'){
#  bg_genes <- readRDS(paste0(bg_path, 'kegg.RDS'))
#} else if(background_genes == 'reactome'){
#  bg_genes <- readRDS(paste0(bg_path, 'reactome.RDS'))
#} else if(background_genes == 'go.bp'){
#  bg_genes <- readRDS(paste0(bg_path, 'go.bp.RDS'))
#} else {
#  stop('Invalid background genes. Select one of the following: KEGG, Reactome, GO, or add new pwl to function')
#}
####
#View(deg_results_list)
#View(bg_genes)
unique(bg_genes$gene)
deg_results_list[1]



# Run clusterProfiler on each sub-dataframe
#View(deg_results_list)
res <- lapply(names(deg_results_list),
              function(x) enricher(gene = deg_results_list[[x]]$SYMBOL,
                                   TERM2GENE = bg_genes))
View(res)
names(res) <- names(deg_results_list)
#Convert the list of enrichResults for each sample_pattern to a dataframe with the pathways
res_df <- lapply(names(res), function(x) rbind(res[[x]]@result))
names(res_df) <- names(res)

res_df <- do.call(rbind, res_df)
#head(res_df)
View(res_df)


res_df <- res_df %>% mutate(minuslog10padj = -log10(p.adjust),
                            diffexpressed = gsub('\\.GOBP.*$|\\.KEGG.*$|\\.REACTOME.*$', '', rownames(res_df)))

View(res_df)

# Subset to those pathways that have p adj < cutoff and gene count > cutoff (you can also do this in the enricher function)
target_pws <- unique(res_df$ID[res_df$p.adjust < padj_cutoff & res_df$Count > genecount_cutoff]) # select only target pathways have p adjusted < 0.05 and at least 6 genes
target_pws
length(res_df$ID)
length(target_pws)
res_df <- res_df[res_df$ID %in% target_pws, ]
View(res_df)

# Save clusterprofiler results
write.csv(res_df, "2-1_trim_resclusterp.csv", row.names = FALSE)

#df_res_df_sign <- res_df_sign[res_df_sign$Description == "GOBP_MITOCHONDRIAL_TRANSLATION",]
#View(df_res_df_sign)


### For visualisation

#install.packages('pheatmap')
#install.packages("DOSE")
#install.packages("enrichplot")
#install.packages("ggupset")
library(pheatmap)
library(DOSE)
library(enrichplot)
library(ggupset)

# Read in the data
res_df <- read.csv('2-1_trim_resclusterp.csv')
View(res_df)
#res_df_sign_i <- res_df_sign[,1:11]
#View(res_df_sign_i)

bg_genes <- readRDS('GO_BP.RDS')
View(bg_genes)
#bg_genes$term <- as.character(bg_genes$term)

# Convert clusterProfiler object to a new "enrichResult" object
# Select only upregulated genes in Severe
#View(res_df)
# I wanna try all genes, not only UP regulated
res_df <- res_df %>% filter(diffexpressed == 'All') %>% 
  dplyr::select(!c('minuslog10padj', 'diffexpressed')) 

#res_df <- res_df %>% dplyr::select(!c('minuslog10padj', 'diffexpressed')) 

# the next is already done
#rownames(res_df) <- res_df$ID
# For visualisation purposes, let's shorten the pathway names
res_df$Description <- gsub('(H|h)iv', 'HIV', 
                           gsub('pd 1', 'PD-1',
                                gsub('ecm', 'ECM', 
                                     gsub('(I|i)nterleukin', 'IL', 
                                          gsub('(R|r)na', 'RNA', 
                                               gsub('(D|d)na', 'DNA',
                                                    gsub(' i ', ' I ', 
                                                         gsub('(A|a)tp ', 'ATP ', 
                                                              gsub('(N|n)adh ', 'NADH ', 
                                                                   gsub('(N|n)ad ', 'NAD ',
                                                                        gsub('t cell', 'T cell',
                                                                             gsub('b cell', 'B cell',
                                                                                  gsub('built from .*', ' (...)',
                                                                                       gsub('mhc', 'MHC',
                                                                                            gsub('mhc class i', 'MHC I', 
                                                                                                 gsub('mhc class ii', 'MHC II', 
                                                                                                      stringr::str_to_sentence(
                                                                                                        gsub('_', ' ',  
                                                                                                             gsub('GOBP_|KEGG_|REACTOME_', '', res_df$Description)))))))))))))))))))



#View(genes_in_data)
#is.character(genes_in_data)
rownames(res_df) <- res_df$ID 
View(res_df)

enrichres <- new("enrichResult",
                 readable = FALSE,
                 result = res_df,
                 pvalueCutoff = 0.05,
                 pAdjustMethod = "BH",
                 qvalueCutoff = 0.2,
                 organism = "human",
                 ontology = "BP",
                 gene = df$SYMBOL,
                 keytype = "SYMBOL",
                 universe = unique(bg_genes$gene),
                 gene2Symbol = character(0),
                 geneSets = bg_genes)

class(enrichres)
View(enrichres@result)

# Barplot
barplot_20 <- barplot(enrichres, showCategory = 20) 
barplot_20
mutate(enrichres, qscore = -log(p.adjust, base = 10)) %>% 
  barplot(x = "qscore")
barplot_path <- "/enrichment/barplot.png"
ggsave(barplot_path,barplot_20)

# Dotplot
dotplot(enrichres, showCategory = 15) + ggtitle("Up-Down_regulated")

# Cnetplot
cnetplot(enrichres)
cnetplot(enrichres, categorySize="pvalue",foldChange = gene_list, showCategory=8)

goplot(enrichres)

View(enrichres)

# Heatplot
heatplot(enrichres, showCategory = 5)

# Treeplot
enrichres2 <- pairwise_termsim(enrichres) # calculate pairwise similarities of the enriched terms using Jaccard’s similarity index
#treeplot(enrichres2)

# Enrichment map 
emapplot(enrichres2)

# Upsetplot
upsetplot(enrichres)


```

## GSEA , Gene Set Enrichment Analysis
```{r}
## 1. Read in data
#df <- read.table("1_2_DEGs.tsv", header = TRUE, sep = "\t")

DEGs <- read_excel("difexp_1-2.xlsx", sheet = "Sheet1")
#df <- read.csv(paste0(in_path, 'expression2.csv'), row.names = 1)
# Remove the first column from the data frame
DEGs <- DEGs[-1]
#View(DEGs)

head(DEGs)
# Get all the genes in your dataset and assign them to my_genes 
# THE SAME AS IN THE TUTORIAL SQUID
df_1_4_7_8 <- DEGs[,c(1,4,7,8)]
#my_genes <- df_2_4_7_8$SYMBOL

# Download gene sets .gmt files
#https://www.gsea-msigdb.org/gsea/msigdb/collections.jsp
# Copy the .gmt file to your folder, in my case, its 'PEA/Background_genes/'
# Then read in the .gmt file
gmt_file <- "BP_subset_GO_Hs.symbols.gmt"

## 2. Prepare background genes

# Download gene sets .gmt files
#https://www.gsea-msigdb.org/gsea/msigdb/collections.jsp

# For GSEA
# Filter out the gmt files for KEGG, Reactome and GOBP
my_genes <- df_1_4_7_8$SYMBOL
bg_path <- "C:/Users/RTIntelektFBT/Desktop/Roman_Project/try_from_almostZERO"
gmt_files <- list.files(path = bg_path,pattern = '.gmt', full.names = TRUE)
gmt_files
bg_genes <- prepare_gmt(gmt_files, my_genes, savefile = FALSE)
#View(bg_genes)
head(df_1_4_7_8)
# Prepare your ranked list of genes
rankings <- sign(df_1_4_7_8$logFC)*(-log10(df_1_4_7_8$P.Value)) # we will use the signed p values from spatial DGE as ranking
names(rankings) <- df_1_4_7_8$SYMBOL # genes as names
#View(rankings)
rankings <- sort(rankings, decreasing = TRUE) # sort genes by ranking
head(rankings)
plot(rankings)

###
#max(rankings)
#min(rankings)
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
#max_ranking <- max(rankings[is.finite(rankings)])
#min_ranking <- min(rankings[is.finite(rankings)])
#rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
#rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
#rankings <- sort(rankings, decreasing = TRUE) # sort genes by ranking
###

ggplot(data.frame(gene_symbol = names(rankings)[1:50], ranks = rankings[1:50]), aes(gene_symbol, ranks)) + 
  geom_point() +
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


## 4. Run GSEA
GSEAres <- fgsea(pathways = bg_genes, # List of gene sets to check
                 stats = rankings,
                 scoreType = 'std', # in this case we have both pos and neg rankings. if only pos or neg, set to 'pos', 'neg'
                 minSize = 10,
                 maxSize = 500,
                 nproc = 1) # for parallelisation

head(GSEAres)
View(GSEAres)
GSEAres_ordered <- GSEAres[order(padj), ]
View(GSEAres_ordered)

## 6. Check results
# Top 6 enriched pathways (ordered by p-val)
head(GSEAres[order(pval), ])

sum(GSEAres[, padj < 0.01])
sum(GSEAres[, pval < 0.01])






number_of_top_pathways_up = 10
number_of_top_pathways_down = 10
topPathwaysUp <- GSEAres[ES > 0][head(order(padj), n = number_of_top_pathways_up), pathway]
topPathwaysDown <- GSEAres[ES < 0][head(order(padj), n = number_of_top_pathways_down), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))

#pdf(file = paste0(filename, '_gsea_top30pathways.pdf'), width = 20, height = 15)
plotGseaTable(bg_genes[topPathways], stats = rankings, fgseaRes = GSEAres, gseaParam = 0.5)
#dev.off()

# Select only independent pathways, removing redundancies/similar pathways
collapsedPathways <- collapsePathways(GSEAres[order(padj)][padj < 0.05], bg_genes, rankings)
mainPathways <- GSEAres[pathway %in% collapsedPathways$mainPathways][order(-NES), pathway]
#pdf(file = paste0('GSEA/Selected_pathways/', paste0(filename, background_genes, '_gsea_mainpathways.pdf')), width = 20, height = 15)
plotGseaTable(bg_genes[mainPathways], rankings, GSEAres, gseaParam = 0.5)
#dev.off()

#If you’d like to export the tables, just uncomment the 2 lines above. You can also export to .png, or other formats:
#png(file = paste0(filename, ‘_gsea_mainpathways.png’), width = 1500, height = 800)
#plotGseaTable(bg_genes[mainPathways], rankings, GSEAres, gseaParam = 0.5)





# plot the most significantly enriched pathway
plotEnrichment(bg_genes[[head(GSEAres[order(padj), ], 1)$pathway]],
               rankings) + 
  labs(title = head(GSEAres[order(padj), ], 1)$pathway)


bg_genes[[head(GSEAres[order(padj), ], 1)$pathway]]

#View(GSEAres_ordered)
#head(GSEAres_ordered,1)
#head(GSEAres[order(padj), ], 2)$pathway
#GSEAres_ordered[2,]

bg_genes[[GSEAres_ordered[2,]$pathway]]
View(bg_genes)
# plot the 2 most significantly enriched pathway
plotEnrichment(bg_genes[[GSEAres_ordered[2,]$pathway]],
               rankings) + 
  labs(title = GSEAres_ordered[2,]$pathway)

# plot the 2 most significantly enriched pathway

plotEnrichment(bg_genes[[GSEAres_ordered[2,]$pathway]],
               rankings) + 
  labs(title = GSEAres_ordered[2,]$pathway)

plotEnrichment(bg_genes[[GSEAres_ordered[142,]$pathway]],
               rankings) + 
  labs(title = GSEAres_ordered[142,]$pathway)


bg_genes[[GSEAres_ordered[1,]$pathway]]
GSEAres_ordered[1,]$pathway
bg_genes[1]

class(bg_genes)
bg_genes[[1]]

GSEAres_ordered$pathway[1:5]

GSEAres_ordered[1:5]$pathway

plotGseaTable(
  pathways = bg_genes[GSEAres_ordered$pathway[1:5]],
  stats = rankings,
  fgseaRes = GSEAres_ordered,
  gseaParam = 1,
  colwidths = c(5, 3, 0.8, 1.2, 1.2),
  pathwayLabelStyle = NULL,
  headerLabelStyle = NULL,
  valueStyle = NULL,
  axisLabelStyle = NULL,
  render = NULL
)

```











